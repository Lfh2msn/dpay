@compiler >= 7
include "List.aes"
include "Pair.aes"
include "Option.aes"
include "./libs/ListUtil.aes"
include "./interfaces/DAOInterface.aes"


payable contract DAO :  DAOInterface = 

    record proposal = {
        title: string,
        description: string,
        creator: address,
        proposal_type: int,
        recipients: map(address, int),
        start_date: int,
        stop_date: int,
        voters: map(address, bool),
        executed: bool,
        status: int,
        created_date: int
        } 
    record simple_state = {
        owner : address,
        title : string,
        description : string,
        percentage: int,
        status: int,
        open: bool,
        created_date: int,
        dao_type: int,
        members_length: int,
        proposals_length: int,
        balance: int
        }
    record state = {
        owner : address,
        title : string,
        description : string,
        percentage: int,
        status: int,
        open: bool,
        created_date: int,
        dao_type: int,
        members : list(address),
        proposals: map(int, proposal),
        member_fund: map(address, int),
        contributor_fund: map(address, int)
        }

    entrypoint init(dao): state =
        dao

    entrypoint get(): simple_state =
        {
          owner=state.owner, 
          title=state.title, 
          description=state.description, 
          percentage=state.percentage, 
          status=state.status, 
          open=state.open, 
          created_date=state.created_date, 
          dao_type=state.dao_type,
          members_length=List.length(state.members), 
          proposals_length=Map.size(state.proposals), 
          balance=Contract.balance
          }

    stateful entrypoint create_proposal(title: string, description: string, proposal_type: int, recipients: map(address, int), start_date: int, stop_date: int) = 
        require(state.status == 1, "!dao_active")
        let new_proposal = {
            title= title,
            description= description,
            creator= Call.caller,
            proposal_type= proposal_type,
            recipients= recipients,
            start_date= start_date,
            stop_date= stop_date,
            voters= {},
            executed= false,
            status= 1,
            created_date= Chain.timestamp
            }
        
        let size = Map.size(state.proposals)  

        put(state{proposals[size] = new_proposal})

    stateful entrypoint vote(index: int, vote_value: bool) =
        require(state.status == 1, "!dao_active")
        require(state.proposals[index].status == 1, "!active")
        let is_member = List.contains(Call.caller, state.members)
        require(is_member, "!member")

        let voted_proposal = Map.member(index, state.proposals)
        require(voted_proposal, "!proposal")

        put(state {proposals[index].voters[Call.caller] = vote_value})

    entrypoint get_proposals(): list(int * proposal) = 
        Map.to_list(state.proposals)


    entrypoint get_member_fund(): list(address * int) =
        Map.to_list(state.member_fund)

    entrypoint get_contributor_fund(): list(address * int) =
        Map.to_list(state.contributor_fund)  

    entrypoint get_members(): list(address) =
        state.members

    payable stateful entrypoint fund() =
        require(state.status == 1, "!dao_active")
        // check contributor or member
        let is_member = List.contains(Call.caller, state.members)
        if (is_member)
            let is_exist_in_map = Map.member(Call.caller, state.member_fund)
            if (is_exist_in_map)
                put(state{ member_fund[Call.caller] = state.member_fund[Call.caller] + Call.value})
            else
                put(state{ member_fund[Call.caller] = Call.value})
        else 
            let is_exist_in_map = Map.member(Call.caller, state.contributor_fund)
            if (is_exist_in_map)
                put(state{ contributor_fund[Call.caller] = state.contributor_fund[Call.caller] + Call.value})     
            else
                put(state{ contributor_fund[Call.caller] = Call.value})
            

    stateful entrypoint execute_proposal(index: int): int =
        require(state.status == 1, "!dao_active")
        let is_exist_proposal = Map.member(index, state.proposals)
        require(is_exist_proposal, "!proposal")

        let voted_proposal = state.proposals[index]
        require(voted_proposal.status == 1, "!active")

        let proposal_voters = voted_proposal.voters
        require(Map.size(proposal_voters) > 0, "!size")

        let proposal_voters_list = Map.to_list(proposal_voters)
        let voted_list = List.filter((a: (address * bool)) => Pair.snd(a) == true, proposal_voters_list)

        if (state.percentage == 100)
            //proposal_voters_list
            require(List.length(state.members) == List.length(voted_list), "!enough_vote")
        else 
            require((List.length(voted_list) * 100 / List.length(state.members) >= state.percentage), "!enough_percentage_vote")
       

        if (voted_proposal.proposal_type != 1)
            require(Chain.timestamp >= voted_proposal.start_date, "start_date>block_timestamp")

        let recipients_and_tokens_list = Map.to_list(voted_proposal.recipients)
        require(ListUtil.validate_expenses(recipients_and_tokens_list), "!enough_balance")
        put(state {proposals[index].executed = true})
        put(state {proposals[index].status = 3})
        let sent_tokens = spend_to_many'(recipients_and_tokens_list, 0, Contract.balance)
        sent_tokens

    entrypoint get_contract_balance(): int =
        Contract.balance

    stateful entrypoint add_member(new_member: address): bool =
        require(state.status == 1, "!dao_active")
        require(Call.caller == state.owner, "!owner")
        let is_member = List.contains(new_member, state.members)
        require(!is_member, "Existed")
        put(state {members = new_member::state.members})
        true 

    stateful entrypoint remove_member(member: address): bool =
        require(state.status == 1, "!dao_active")
        require(Call.caller == state.owner, "!owner")
        let is_member = List.contains(member, state.members)
        require(is_member, "!Existed")
        put(state {members = List.filter((m) => m != member, state.members)})
        true

    stateful entrypoint join(): bool =
        let member = Call.caller
        require(state.status == 1, "!dao_active")
        require(state.open, "!open_dao")
        let is_member = List.contains(member, state.members)
        require(!is_member, "Existed")
        put(state {members = member::state.members})
        true


    stateful entrypoint leave(): bool =
        let member = Call.caller
        require(state.status == 1, "!dao_active")
        require(state.open, "!open_dao")
        let is_member = List.contains(member, state.members)
        require(is_member, "!Existed")
        put(state {members = List.filter((m) => m != member, state.members)})
        true

    // 1: active, 2: paused, 3: defunctioned    
    stateful entrypoint change_dao_status(newStatus: int): int = 
        require(Call.caller == state.owner, "!dao_owner")
        require(state.status != 3, "Defunctioned")
        put(state {status= newStatus} )
        newStatus  

    // 1: active, 2: paused, 3: cancelled   
    stateful entrypoint change_proposal_status(index: int, newStatus: int): int =
        require(state.status == 1, "!dao_active")
        let is_exist_proposal = Map.member(index, state.proposals)
        require(is_exist_proposal, "!proposal")
        let currentProposal = state.proposals[index]

        require(Call.caller == currentProposal.creator, "!proposal_creator")

        if (!currentProposal.executed && currentProposal.status != 3)
            // Change status here
            put(state{proposals[index].status = newStatus})
            newStatus
        else    
            0        


    // traverse through list of maps
    stateful function spend_to_many'(list, total_tokens_spend, amount_left) : int = 
        switch(list)
            [] => total_tokens_spend
            (address, tokens) :: l' =>
                require(amount_left >= tokens, "!enough_tokens")
                Chain.spend(address,tokens) 
                spend_to_many'(l', total_tokens_spend + tokens, amount_left - tokens)





